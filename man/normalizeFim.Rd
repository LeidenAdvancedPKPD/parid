% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/FisherInfo.r
\name{normalizeFim}
\alias{normalizeFim}
\title{Normalize Fisher Information Matrix}
\usage{
normalizeFim(
  fim,
  thetaNorm = TRUE,
  omegaNorm = TRUE,
  sigmaNorm = TRUE,
  checkPos = TRUE
)
}
\arguments{
\item{fim}{A matrix with row and column names containing the FIM,
as produced by \code{\link{calcFimFromMatrix}} or \code{\link{calcFimFromModel}}.}

\item{thetaNorm}{Vector (not necessarily named) of booleans of the same dimension as the theta vector
used to create the FIM (so not just the variable theta's).
The value \code{TRUE} means the corresponding structural parameter should be normalized in the FIM,
\code{FALSE} means not.
Instead of a vector, may also provide a single boolean, where \code{TRUE} (default) stands for a vector of
all \code{TRUE}, and \code{FALSE} for a vector of all \code{FALSE}.
May also provide a character vector with the names of the parameters to be normalized.
Invalid names are ignored, with a warning.}

\item{omegaNorm}{Vector (not necessarily named) of booleans of the same dimension as the omega matrix
used to create the FIM (so not just the variable omega's).
The value \code{TRUE} means the corresponding individual parameter should be normalized in the FIM,
\code{FALSE} means not.
Instead of a vector, may also provide a single boolean, where \code{TRUE} (default) stands for a vector of
all \code{TRUE}, and \code{FALSE} for a vector of all \code{FALSE}.
May also provide a character vector with the names of the parameters to be normalized.
Invalid names are ignored, with a warning.}

\item{sigmaNorm}{Vector (not necessarily named) of booleans of the same dimension as the sigma matrix
used to create the FIM (so not just the variable sigma's).
The value \code{TRUE} means the corresponding residual parameter should be normalized in the FIM,
\code{FALSE} means not.
Instead of a vector, may also provide a single boolean, where \code{TRUE} (default) stands for a vector of
all \code{TRUE}, and \code{FALSE} for a vector of all \code{FALSE}.
May also provide a character vector with the names of the parameters to be normalized.
Invalid names are ignored, with a warning.}

\item{checkPos}{If \code{TRUE} (default), it is checked that parameters to be normalized in the FIM
are strictly positive. If \code{FALSE}, this is not checked.}
}
\value{
A matrix in same format as \code{fim}, where the values are normalized as specified, and the
attributes are adapted accordingly.
The function displays an error and returns \code{NULL} if the input is not in the specified format.
}
\description{
Normalizes the given Fisher Information Matrix (FIM) with respect to the given parameters.
Effectively this means that the derivatives with respect to these parameters are taken relative to their size, i.e.,
they are taken with respect to the logarithms of these parameters.
This should be used for those parameters for which relative changes are relevant, rather than absolute changes.
Normalization is accomplished by left and right multiplication of the given FIM by a diagonal matrix of normalizing factors.
The normalizing factors are the values of the corresponding parameters, and are also given as input.
If the given FIM was already normalized (as indicated by the "thetaNormalized", "omegaNormalized" and
"sigmaNormalized" attributes) then this normalization is undone.
}
\details{
This can be used for parameters for which relative changes in value are the relevant quantity,
rather than absolute changes, e.g., clearances, rates, volumes, and additive errors.
Absolute changes in such parameters are not relevant because they depend on the chosen units.
Relative changes do not suffer from this problem.
It should typically also be used for parameters that already have a relative size,
such as IIV variances (in case of multiplicative IIV effects, i.e., as exp(eta) factors),
proportional errors, powers ("gamma"), Imax, etc.
The reason is that these parameters may also be scaled by arbitrary multiplication factors
(e.g., a proportional error can be modelled as a fraction or as a percentage).
}
\author{
Martijn van Noort
}
